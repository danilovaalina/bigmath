# Арифметика с большими числами в Go

Простая программа на Go, демонстрирующая выполнение базовых арифметических операций (сложение, вычитание, умножение, деление) над числами, превышающими \(2^20\) (1 048 576).

## Структура проекта

```
bigmath/
├── main.go          # Демонстрация арифметики с int64 и math/big
└── README.md        
```


## Особенности

- Использует два подхода:
  - **`int64`** - для чисел в пределах стандартного диапазона (быстро, но возможное переполнение при умножении больших значений).
  - **`math/big`** - для произвольно больших целых чисел без риска переполнения (рекомендуется для надёжности).
- Показывает разницу между ограниченной и неограниченной арифметикой.
- Включает пример деления с остатком через `DivMod`.

## Проблема переполнения и решение через `math/big`

При использовании встроенного типа `int64` возможно **арифметическое переполнение**, особенно при умножении больших чисел. Например:

```go
var a int64 = 1_000_000_000  // 10^9
var b int64 = 10_000_000_000 // 10^10
fmt.Println(a * b) // Выведет: -8446744073709551616 (неправильный результат)
```
Фактически, 10⁹ × 10¹⁰ = 10¹⁹, но максимальное значение `int64` - около 9.2 × 10¹⁸. Результат будто «переходит через край» и возвращается с противоположного конца, становится отрицательным - это и есть **переполнение**.

С пакетом `math/big` такой проблемы нет:

```go
A := big.NewInt(1_000_000_000)
B := big.NewInt(10_000_000_000)
product := new(big.Int).Mul(A, B)
fmt.Println(product) // Выведет: 10000000000000000000 (правильный результат!)
```

`math/big` поддерживает целые числа **произвольной длины**, ограниченные только доступной памятью, и гарантирует точность вычислений. Поэтому для критически важных или потенциально очень больших значений рекомендуется использовать именно его.

## Зачем это нужно?

Хотя числа больше миллиона легко помещаются в `int64`, при умножении или возведении в степень легко выйти за пределы диапазона. Пакет `math/big` решает эту проблему.
